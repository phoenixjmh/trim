Based on your video operations code, I can help you add audio stream reading. The approach will be similar to how you're handling video - you'll need to find the audio stream index and set up the audio codec context. Here's a guide on extending your code:

First, modify your AVStreamInfo struct to include audio-related fields (I assume this is in your header):

cppCopystruct AVStreamInfo {
    AVFormatContext* pFormatContext;
    AVCodecContext* pCodecContext;
    // Add these for audio:
    AVCodecContext* audio_codec_context;
    int audio_stream_index;
    int video_stream_index;
    int64_t current_timestamp;
};

Then modify your OpenVideoStream function to also open the audio stream:

cppCopybool OpenVideoStream(const char* input_file, AVStreamInfo& stream_info) {
    AVFormatContext* pFormatContext = avformat_alloc_context();
    
    AV_CHECK(avformat_open_input(&pFormatContext, input_file, NULL, NULL),
             "Failed to open input file");

    avformat_find_stream_info(pFormatContext, NULL);

    // Find both video and audio streams
    int video_stream_idx = -1;
    int audio_stream_idx = -1;
    
    for (int i = 0; i < pFormatContext->nb_streams; i++) {
        if (pFormatContext->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
            video_stream_idx = i;
        }
        else if (pFormatContext->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
            audio_stream_idx = i;
        }
    }

    // Handle video codec (your existing code)
    if (video_stream_idx != -1) {
        auto& video_codec_parameters = pFormatContext->streams[video_stream_idx]->codecpar;
        const AVCodec* pLocalCodec = avcodec_find_decoder(video_codec_parameters->codec_id);
        AVCodecContext* pCodecContext = avcodec_alloc_context3(pLocalCodec);
        AV_CHECK(avcodec_parameters_to_context(pCodecContext, video_codec_parameters),
                "Failed to initialize Video codec context");
        AV_CHECK(avcodec_open2(pCodecContext, pLocalCodec, NULL),
                "Failed to open video codec");
        stream_info.pCodecContext = pCodecContext;
    }

    // Handle audio codec
    if (audio_stream_idx != -1) {
        auto& audio_codec_parameters = pFormatContext->streams[audio_stream_idx]->codecpar;
        const AVCodec* audio_codec = avcodec_find_decoder(audio_codec_parameters->codec_id);
        AVCodecContext* audio_context = avcodec_alloc_context3(audio_codec);
        AV_CHECK(avcodec_parameters_to_context(audio_context, audio_codec_parameters),
                "Failed to initialize Audio codec context");
        AV_CHECK(avcodec_open2(audio_context, audio_codec, NULL),
                "Failed to open audio codec");
        stream_info.audio_codec_context = audio_context;
    }

    stream_info.pFormatContext = pFormatContext;
    stream_info.video_stream_index = video_stream_idx;
    stream_info.audio_stream_index = audio_stream_idx;
    return true;
}

Here's a function to read audio samples:

cppCopybool ReadAudioFrame(AVStreamInfo& stream_info, std::vector<float>& samples) {
    AVPacket* packet = av_packet_alloc();
    AVFrame* frame = av_frame_alloc();

    bool got_frame = false;
    while (av_read_frame(stream_info.pFormatContext, packet) >= 0) {
        if (packet->stream_index == stream_info.audio_stream_index) {
            int response = avcodec_send_packet(stream_info.audio_codec_context, packet);
            if (response < 0) {
                av_packet_unref(packet);
                continue;
            }

            response = avcodec_receive_frame(stream_info.audio_codec_context, frame);
            if (response == AVERROR(EAGAIN) || response == AVERROR_EOF) {
                av_packet_unref(packet);
                continue;
            }

            // Convert audio to float planar format if needed
            int num_samples = frame->nb_samples * frame->channels;
            samples.resize(num_samples);
            
            // If the audio is already float planar (AV_SAMPLE_FMT_FLTP)
            if (frame->format == AV_SAMPLE_FMT_FLTP) {
                float* audio_data = (float*)frame->data[0];
                memcpy(samples.data(), audio_data, num_samples * sizeof(float));
            } else {
                // You might need to add conversion here using swresample
                // for different audio formats
            }

            got_frame = true;
            break;
        }
        av_packet_unref(packet);
    }

    av_frame_free(&frame);
    av_packet_free(&packet);
    return got_frame;
}

Don't forget to update your CloseVideoStream function to clean up audio resources:

cppCopyvoid CloseVideoStream(AVStreamInfo& stream_info) {
    if (stream_info.pFormatContext) {
        avformat_close_input(&stream_info.pFormatContext);
        avformat_free_context(stream_info.pFormatContext);
    }
    if (stream_info.pCodecContext) {
        avcodec_free_context(&stream_info.pCodecContext);
    }
    if (stream_info.audio_codec_context) {
        avcodec_free_context(&stream_info.audio_codec_context);
    }
    std::cout << "Closed video stream\n";
}
You'll likely need to add audio resampling using SwrContext if you want to convert the audio to a specific format or sample rate. Would you like me to show how to add that as well?
Also, make sure to link against the FFmpeg audio libraries (avcodec, avformat, swresample) in your CMake file if you haven't already.